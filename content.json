{"posts":[{"title":"多远都要在一起","text":"42 想听你听过的音乐 想看你看过的小说 我想收集每一刻 我想看到你眼中的世界 想到你到过的地方 和你曾度过的时光 不想错过每一刻 多希望我一直在你身旁 未来何从何去 你快乐我也就没关系 对你我最熟悉 你爱自由我却更爱你 我能习惯远距离 爱总是身不由己 宁愿换个方式至少还能遥远爱着你 爱能克服远距离 多远都要在一起 你已经不再存在我的世界里 请不要离开我的回忆 想你说爱我的语气 想你望着我的眼睛 不想忘记每一刻 用思念让我们一直前进 想像你失落的唇印 想象你失约的旅行 想象你离开的那一刻 如果我有留下你的勇气 我能习惯远距离 爱总是身不由己 宁愿换个方式至少还能遥远爱着你 爱能克服远距离 多远都要在一起 我已经不再存在你的心里 就让我独自守着回忆 如果阳光永远都炙热 如果彩虹不会掉颜色 你能不能不要离开呢 我能习惯远距离 爱总是身不由己 宁愿换个方式至少还能遥远爱着你 爱能克服远距离 多远都要在一起 你已经不再存在我的世界里 请不要离开我回忆 请不要离开不要离开我的回忆 var ap = new APlayer({ element: document.getElementById(\"aplayer-ddYtQfYz\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"多远都要在一起\", author: \"邓紫棋\", url: \"/2025/02/19/你已经不再存在我的世界里/多远都要在一起-G.E.M.邓紫棋.mp3\", pic: \"\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","link":"/2025/02/19/%E4%BD%A0%E5%B7%B2%E7%BB%8F%E4%B8%8D%E5%86%8D%E5%AD%98%E5%9C%A8%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E9%87%8C/"},{"title":"Django Channels 异步操作问题笔记","text":"Django Channels 异步缓存操作错误解决方案问题描述在 Django Channels 的 WebSocket 消费者中调用缓存操作时出现以下错误：获取在线用户列表错误: You cannot call this from an async context - use a thread or sync_to_async. 问题根源1. 异步/同步上下文冲突 Django 的默认缓存操作（cache.get/cache.set）是同步操作 WebSocket 消费者继承自 AsyncWebsocketConsumer，运行在异步事件循环中 直接混用会导致事件循环阻塞，引发 SynchronousOnlyOperation 异常 2. 常见触发场景1234567891011121314151617181920212223242526# 错误示例：在异步方法中直接调用同步缓存async def get_online_users(self): online_users = cache.get(self.room_group_name) # 此处会报错---## 解决方案### 使用异步装饰器封装```pythonfrom channels.db import database_sync_to_asyncclass ChatConsumer(AsyncWebsocketConsumer): # 同步操作转异步 @database_sync_to_async def _get_cache(self, key): return cache.get(key, []) @database_sync_to_async def _set_cache(self, key, value): return cache.set(key, value, timeout=None) # 异步方法调用 async def get_online_users(self): online_users = await self._get_cache(self.room_group_name) await self._set_cache(self.room_group_name, updated_users) 关键技术要点 要点 说明 示例 异步装饰器 将同步方法转换为协程 @database_sync_to_async await 调用 必须等待异步操作完成 await self._get_cache() 上下文隔离 禁止在异步方法中直接调用同步 I/O 直接使用 cache.get()","link":"/2025/03/31/Django-Channels-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[],"pages":[]}